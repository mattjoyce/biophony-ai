CREATE TABLE audio_files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            filename TEXT NOT NULL,
            filepath TEXT NOT NULL UNIQUE,
            file_size INTEGER,
            recording_datetime DATETIME,
            timezone TEXT,
            audiomoth_id TEXT,
            firmware_version TEXT,
            duration_seconds REAL,
            samplerate_hz INTEGER,
            channels INTEGER,
            samples INTEGER,
            gain TEXT,
            battery_voltage REAL,
            low_battery BOOLEAN,
            temperature_c REAL,
            recording_state TEXT,
            deployment_id TEXT,
            external_microphone BOOLEAN,
            comment TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        , spectrogram_min REAL, spectrogram_max REAL, aci_min REAL, aci_max REAL, aci_mean REAL, weather_id INTEGER REFERENCES weather_data(id), site_id INTEGER REFERENCES weather_sites(id), npz_filepath TEXT, time_since_last TEXT, time_to_next TEXT);
CREATE TABLE sqlite_sequence(name,seq);
CREATE TABLE annotations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            audio_file_id INTEGER,
            start_time REAL,
            end_time REAL,
            label TEXT,
            annotation_type TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (audio_file_id) REFERENCES audio_files (id)
        );
CREATE TABLE global_stats (
            id INTEGER PRIMARY KEY,
            stat_name TEXT UNIQUE,
            stat_value REAL,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
CREATE TABLE weather_sites (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    latitude REAL NOT NULL,
                    longitude REAL NOT NULL,
                    elevation REAL,
                    timezone TEXT,
                    timezone_abbreviation TEXT,
                    UNIQUE(latitude, longitude)
                );
CREATE TABLE weather_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    site_id INTEGER REFERENCES weather_sites(id),
                    datetime TEXT NOT NULL,
                    temperature_2m REAL,
                    relative_humidity_2m REAL,
                    precipitation REAL,
                    wind_speed_10m REAL,
                    weather_code INTEGER,
                    cloud_cover REAL,
                    pressure_msl REAL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, sunrise_time TEXT, sunset_time TEXT,
                    UNIQUE(site_id, datetime)
                );
CREATE TABLE index_configurations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            config_name TEXT NOT NULL,
            index_name TEXT NOT NULL,
            processor_name TEXT NOT NULL,
            config_fragment TEXT NOT NULL,
            config_hash TEXT NOT NULL,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            
            UNIQUE(config_name, index_name, config_hash)
        );
CREATE TABLE acoustic_indices_core (
                    id INTEGER PRIMARY KEY,
                    file_id INTEGER NOT NULL REFERENCES audio_files(id),
                    index_name TEXT NOT NULL,
                    chunk_index INTEGER NOT NULL,
                    start_time_sec REAL NOT NULL,
                    value REAL,
                    processing_type TEXT NOT NULL,
                    computed_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );
CREATE INDEX idx_recording_datetime ON audio_files(recording_datetime);
CREATE INDEX idx_audiomoth_id ON audio_files(audiomoth_id);
CREATE INDEX idx_filepath ON audio_files(filepath);
CREATE INDEX idx_annotations_file ON annotations(audio_file_id);
CREATE INDEX idx_config_index_name 
        ON index_configurations (config_name, index_name)
        ;
CREATE INDEX idx_core_file_id ON acoustic_indices_core(file_id)
            ;
CREATE INDEX idx_core_file_index ON acoustic_indices_core(file_id, index_name)
            ;
CREATE INDEX idx_core_type ON acoustic_indices_core(processing_type)
            ;
CREATE INDEX idx_core_name ON acoustic_indices_core(index_name)
            ;
CREATE VIEW index_statistics AS
                SELECT 
                    ai.processing_type,
                    ai.index_name,
                    COUNT(*) as measurement_count,
                    COUNT(DISTINCT ai.file_id) as file_count,
                    MIN(ai.value) as min_value,
                    MAX(ai.value) as max_value,
                    AVG(ai.value) as avg_value,
                    MIN(ai.computed_at) as first_computed,
                    MAX(ai.computed_at) as last_computed
                FROM acoustic_indices_core ai
                GROUP BY ai.processing_type, ai.index_name
/* index_statistics(processing_type,index_name,measurement_count,file_count,min_value,max_value,avg_value,first_computed,last_computed) */;
CREATE VIEW acoustic_indices AS
SELECT 
    ai.id,
    ai.file_id,
    af.filepath as wav_filepath,
    af.npz_filepath,
    af.recording_datetime,
    af.time_since_last,
    af.time_to_next,
    ai.index_name,
    ai.chunk_index,
    ai.start_time_sec,
    ai.value,
    ai.processing_type,
    ai.computed_at,
    wd.temperature_2m,
    wd.relative_humidity_2m,
    wd.sunrise_time,
    wd.sunset_time
FROM acoustic_indices_core ai
JOIN audio_files af ON ai.file_id = af.id
LEFT JOIN weather_data wd ON af.weather_id = wd.id
/* acoustic_indices(id,file_id,wav_filepath,npz_filepath,recording_datetime,time_since_last,time_to_next,index_name,chunk_index,start_time_sec,value,processing_type,computed_at,temperature_2m,relative_humidity_2m,sunrise_time,sunset_time) */;
CREATE VIEW indices_by_file AS
SELECT 
    af.filename,
    af.filepath as wav_filepath,
    af.npz_filepath,
    af.recording_datetime,
    af.time_since_last,
    af.time_to_next,
    ai.index_name,
    ai.chunk_index,
    ai.start_time_sec,
    ai.value,
    ai.processing_type,
    ai.computed_at,
    wd.temperature_2m,
    wd.relative_humidity_2m,
    wd.sunrise_time,
    wd.sunset_time
FROM acoustic_indices_core ai
JOIN audio_files af ON ai.file_id = af.id
LEFT JOIN weather_data wd ON af.weather_id = wd.id
ORDER BY af.filepath, ai.index_name, ai.chunk_index
/* indices_by_file(filename,wav_filepath,npz_filepath,recording_datetime,time_since_last,time_to_next,index_name,chunk_index,start_time_sec,value,processing_type,computed_at,temperature_2m,relative_humidity_2m,sunrise_time,sunset_time) */;
CREATE VIEW bioacoustic_temporal AS
SELECT 
    af.id,
    af.filename,
    af.filepath,
    af.recording_datetime,
    af.time_since_last,
    af.time_to_next,
    af.audiomoth_id,
    wd.sunrise_time,
    wd.sunset_time,
    wd.temperature_2m,
    wd.relative_humidity_2m,
    wd.precipitation,
    wd.wind_speed_10m,
    ws.name as site_name,
    ws.latitude,
    ws.longitude,
    CASE 
        WHEN af.time_since_last LIKE 'SR+%' AND CAST(SUBSTR(af.time_since_last, 4, 2) AS INTEGER) <= 2 THEN 'Dawn'
        WHEN af.time_since_last LIKE 'SS+%' AND CAST(SUBSTR(af.time_since_last, 4, 2) AS INTEGER) <= 2 THEN 'Dusk'
        WHEN af.time_since_last LIKE 'SR+%' AND CAST(SUBSTR(af.time_since_last, 4, 2) AS INTEGER) BETWEEN 3 AND 12 THEN 'Day'
        WHEN af.time_since_last LIKE 'SS+%' AND CAST(SUBSTR(af.time_since_last, 4, 2) AS INTEGER) BETWEEN 3 AND 12 THEN 'Evening'
        ELSE 'Night'
    END as bioacoustic_period
FROM audio_files af
LEFT JOIN weather_data wd ON af.weather_id = wd.id
LEFT JOIN weather_sites ws ON af.site_id = ws.id
WHERE af.time_since_last IS NOT NULL
ORDER BY af.recording_datetime
/* bioacoustic_temporal(id,filename,filepath,recording_datetime,time_since_last,time_to_next,audiomoth_id,sunrise_time,sunset_time,temperature_2m,relative_humidity_2m,precipitation,wind_speed_10m,site_name,latitude,longitude,bioacoustic_period) */;
