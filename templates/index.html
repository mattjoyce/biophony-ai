<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AudioMoth Spectrogram Viewer</title>
    <!-- Howler.js for robust audio playback -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <!-- easepick for date picker -->
    <script src="https://cdn.jsdelivr.net/npm/@easepick/bundle@1.2.1/dist/index.umd.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            font-size: 12px;
            color: #666;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .viewer-container {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        .info-panels {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .coordinates-panel {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            min-width: 120px;
        }
        .coordinates-panel div {
            margin: 2px 0;
        }
        .weather-panel {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            min-width: 120px;
        }
        .weather-panel div {
            margin: 2px 0;
        }
        .canvas-container {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            width: fit-content;
            height: fit-content;
            position: relative;
        }
        .spectrogram-container {
            position: relative;
            display: inline-block;
        }
        .playback-cursor {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, 
                rgba(255, 255, 255, 0.9), 
                rgba(255, 255, 255, 0.7));
            box-shadow: 
                0 0 2px rgba(0, 0, 0, 0.8),
                0 0 6px rgba(255, 255, 255, 0.5);
            pointer-events: none;
            display: none;
            z-index: 10;
            transition: left 0.1s ease-out;
        }
        .control-group.playback-controls {
            display: none;
        }
        .control-group.playback-controls.has-audio {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .playback-controls .time-display {
            color: #333;
            font-size: 14px;
            font-weight: normal;
            white-space: nowrap;
        }
        .crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        .crosshair-vertical {
            width: 1px;
            height: 300px;
            background: rgba(255, 255, 255, 0.7);
            top: 0;
        }
        .crosshair-horizontal {
            width: 1000px;
            height: 1px;
            background: rgba(255, 255, 255, 0.7);
            left: 0;
        }
        #spectrogramCanvas {
            display: block;
            width: 1000px;
            height: 300px;
            max-width: 100%;
            border: 1px solid #ccc;
        }
        .error {
            color: #dc3545;
            padding: 10px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            margin-top: 10px;
        }
        .info {
            margin-top: 10px;
            padding: 10px;
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            font-size: 14px;
        }
        .custom-timeline-container {
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .timeline-canvas-container {
            position: relative;
            padding: 20px;
            background: #fafafa;
            border-top: 1px solid #eee;
        }
        .timeline-canvas {
            width: 100%;
            height: 120px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: grab;
            display: block;
        }
        .timeline-canvas:active {
            cursor: grabbing;
        }
        .timeline-canvas.over-point {
            cursor: pointer;
        }
        .timeline-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
        }
        .timeline-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }
        
        /* Ensure easepick date picker appears on top */
        .easepick-wrapper {
            z-index: 9999 !important;
        }
        .adjustment-value {
            font-size: 11px;
            color: #666;
            font-family: monospace;
            min-width: 30px;
            text-align: center;
            margin-left: 8px;
        }
        
        /* Remove custom easepick styling - let it use defaults */
    </style>
    <!-- NO CSS LINK - easepick loads its own CSS via JavaScript -->
</head>
<body>
    <div class="container">
        <h2 style="margin: 0 0 15px 0; font-size: 18px; color: #333;">AudioMoth Spectrogram Viewer</h2>
        
        <div class="controls">
            <div class="control-group">
                <label for="datepicker">Date:</label>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <button onclick="changeDate(-1)" id="prevDate">‚óÄ</button>
                    <input type="text" id="datepicker" readonly style="width: 100px; cursor: pointer;">
                    <button onclick="changeDate(1)" id="nextDate">‚ñ∂</button>
                </div>
            </div>
            
            <div class="control-group">
                <label for="colormap">Color Map:</label>
                <select id="colormap">
                    <option value="viridis">Viridis</option>
                    <option value="plasma">Plasma</option>
                    <option value="inferno">Inferno</option>
                    <option value="magma">Magma</option>
                    <option value="cividis">Cividis</option>
                    <option value="jet">Jet</option>
                    <option value="hot">Hot</option>
                    <option value="cool">Cool</option>
                    <option value="spring">Spring</option>
                    <option value="summer">Summer</option>
                    <option value="autumn">Autumn</option>
                    <option value="winter">Winter</option>
                    <option value="copper">Copper</option>
                    <option value="bone">Bone</option>
                    <option value="pink">Pink</option>
                    <option value="gray">Grayscale</option>
                    <option value="seismic">Seismic</option>
                    <option value="RdYlBu">RdYlBu</option>
                    <option value="Spectral">Spectral</option>
                    <option value="coolwarm">Cool Warm</option>
                </select>
            </div>
            
            <div class="control-group playback-controls">
                <label>Audio Playback:</label>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <button class="play-pause-btn">‚ñ∂Ô∏è</button>
                    <button class="stop-btn">‚èπÔ∏è</button>
                    <span class="time-display">00:00 / 15:00</span>
                </div>
            </div>
            
            <div class="control-group">
                <label for="gamma">Gamma:</label>
                <input type="range" id="gamma" min="0.1" max="3.0" value="1.0" step="0.1">
                <span class="adjustment-value">1.0</span>
            </div>
        </div>
        
        <div class="custom-timeline-container">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding: 10px;">
                <label>Timeline:</label>
                <div style="display: flex; gap: 5px; margin-left: auto;">
                    <button onclick="navigateToFile('prev')" id="prevFile" title="Previous file (chronological)">‚óÄ Prev</button>
                    <button onclick="navigateToFile('next')" id="nextFile" title="Next file (chronological)">Next ‚ñ∂</button>
                    <button onclick="zoomTimelineIn()" id="zoomIn" title="Zoom in (halve time range)">üîç+</button>
                    <button onclick="zoomTimelineOut()" id="zoomOut" title="Zoom out (double time range)">üîç-</button>
                    <button onclick="resetTimelineZoom()" id="resetTimelineZoom" title="Reset timeline zoom">Reset View</button>
                </div>
            </div>
            <div class="timeline-canvas-container">
                <canvas id="customTimeline" class="timeline-canvas"></canvas>
                <div id="timelineTooltip" class="timeline-tooltip"></div>
            </div>
            <!-- Keep time selector as backup for now -->
            <div style="margin-top: 10px; padding: 10px; border-top: 1px solid #eee;">
                <label>Direct Selection:</label>
                <select id="timeSlotSelector" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-left: 10px;">
                    <option value="">Select a time slot...</option>
                </select>
            </div>
        </div>
        
        <div class="viewer-container">
            <div class="info-panels">
                <div class="coordinates-panel">
                    <div><strong>Position:</strong></div>
                    <div id="pixelCoords">x:---- y:----</div>
                    <div id="timeCoords">Time: --:--:--</div>
                    <div id="freqCoords">Freq: ---- Hz</div>
                </div>
                <div class="weather-panel">
                    <div><strong>Weather:</strong></div>
                    <div id="temperature">Temp: --¬∞C</div>
                    <div id="humidity">Humidity: --%</div>
                    <div id="windSpeed">Wind: -- km/h</div>
                    <div id="precipitation">Rain: -- mm</div>
                </div>
            </div>
            <div class="spectrogram-container" data-filename="" data-duration="900">
                <div class="canvas-container">
                    <canvas id="spectrogramCanvas"></canvas>
                    <div id="crosshairVertical" class="crosshair crosshair-vertical" style="display: none;"></div>
                    <div id="crosshairHorizontal" class="crosshair crosshair-horizontal" style="display: none;"></div>
                    <div class="playback-cursor"></div>
                </div>
            </div>
        </div>
        
        <div id="errorMessage" class="error" style="display: none;"></div>
        <div id="infoMessage" class="info" style="display: none;"></div>
        <div id="filePathMessage" class="info" style="display: none;"></div>
    </div>

    <script>
        let colormapCache = {};
        let melScaleData = null;
        let currentPlayer = null;

        // Global function to stop all audio
        function stopAllAudio() {
            if (currentPlayer) {
                currentPlayer.stop();
            }
            // Also stop any Howler instances that might be playing
            if (typeof Howler !== 'undefined') {
                Howler.stop();
            }
        }

        // Image adjustment variables
        let imageAdjustments = {
            gamma: 1.0
        };

        // Apply gamma adjustment to canvas (works on current canvas content, not original)
        function applyImageAdjustments(canvas) {
            if (!canvas || imageAdjustments.gamma === 1.0) return;
            
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const gamma = 1.0 / imageAdjustments.gamma; // Gamma correction
            
            // Create gamma lookup table for performance
            const gammaTable = new Array(256);
            for (let i = 0; i < 256; i++) {
                gammaTable[i] = Math.pow(i / 255, gamma) * 255;
            }
            
            for (let i = 0; i < data.length; i += 4) {
                // Apply gamma to RGB channels (skip alpha)
                for (let c = 0; c < 3; c++) {
                    const value = data[i + c];
                    data[i + c] = Math.max(0, Math.min(255, Math.round(gammaTable[value])));
                }
                // Alpha channel (data[i + 3]) remains unchanged
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // Update gamma display value
        function updateAdjustmentDisplays() {
            document.querySelector('#gamma + .adjustment-value').textContent = imageAdjustments.gamma.toFixed(1);
        }

        // Reset gamma to 1.0
        function resetGamma() {
            imageAdjustments.gamma = 1.0;
            document.getElementById('gamma').value = 1.0;
            updateAdjustmentDisplays();
            
            const canvas = document.getElementById('spectrogramCanvas');
            if (canvas && window.originalImageData) {
                // Reapply colormap without gamma
                const colormap = document.getElementById('colormap').value;
                applyColormap(window.originalImageData, colormap).then(coloredImageData => {
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(coloredImageData, 0, 0);
                });
            }
        }

        // Update weather display
        function updateWeatherDisplay(weatherData) {
            document.getElementById('temperature').textContent = 
                weatherData.temperature !== null ? `Temp: ${weatherData.temperature}¬∞C` : 'Temp: --¬∞C';
            
            document.getElementById('humidity').textContent = 
                weatherData.humidity !== null ? `Humidity: ${weatherData.humidity}%` : 'Humidity: --%';
            
            document.getElementById('windSpeed').textContent = 
                weatherData.wind_speed !== null ? `Wind: ${weatherData.wind_speed} km/h` : 'Wind: -- km/h';
            
            document.getElementById('precipitation').textContent = 
                weatherData.precipitation !== null ? `Rain: ${weatherData.precipitation} mm` : 'Rain: -- mm';
        }

        // Clear weather display
        function clearWeatherDisplay() {
            document.getElementById('temperature').textContent = 'Temp: --¬∞C';
            document.getElementById('humidity').textContent = 'Humidity: --%';
            document.getElementById('windSpeed').textContent = 'Wind: -- km/h';
            document.getElementById('precipitation').textContent = 'Rain: -- mm';
        }

        class SpectrogramAudioPlayer {
            constructor(containerElement) {
                this.container = containerElement;
                this.spectrogramImg = containerElement.querySelector('#spectrogramCanvas');
                this.cursor = containerElement.querySelector('.playback-cursor');
                this.controlsPanel = document.querySelector('.control-group.playback-controls');
                this.filename = containerElement.dataset.filename;
                this.duration = parseInt(containerElement.dataset.duration);
                this.audio = null;
                this.animationId = null;
                
                this.setupEventListeners();
                
                // Preload audio for faster playback
                setTimeout(() => this.preloadAudio(), 100);
            }
            
            setupEventListeners() {
                // Click-to-play functionality
                this.spectrogramImg.addEventListener('click', (e) => {
                    const timeOffset = this.calculateTimeFromClick(e);
                    this.playAtTime(timeOffset);
                });
                
                // Control buttons - now in external controls panel
                const playPauseBtn = this.controlsPanel.querySelector('.play-pause-btn');
                const stopBtn = this.controlsPanel.querySelector('.stop-btn');
                
                if (playPauseBtn) {
                    playPauseBtn.addEventListener('click', () => {
                        this.togglePlayPause();
                    });
                }
                
                if (stopBtn) {
                    stopBtn.addEventListener('click', () => {
                        this.stop();
                    });
                }
            }
            
            calculateTimeFromClick(clickEvent) {
                const rect = this.spectrogramImg.getBoundingClientRect();
                const clickX = clickEvent.clientX - rect.left;
                const imageWidth = this.spectrogramImg.offsetWidth;
                
                // Calculate time offset (0.9 seconds per pixel for 1000px/900s)
                const timeOffset = (clickX / imageWidth) * this.duration;
                return Math.max(0, Math.min(timeOffset, this.duration));
            }
            
            preloadAudio() {
                if (!this.filename || this.audio) return;
                
                // Preload audio file for faster playback
                this.audio = new Howl({
                    src: [`/api/audio/${this.filename}`],
                    format: ['wav'],
                    preload: true,
                    onload: () => {
                        console.log('Audio preloaded successfully');
                    },
                    onplay: () => {
                        console.log('Audio onplay event - starting cursor animation');
                        this.updatePlayPauseButton(true);
                        this.startCursorAnimation();
                    },
                    onpause: () => {
                        this.updatePlayPauseButton(false);
                    },
                    onstop: () => {
                        this.stopCursorAnimation();
                        this.updatePlayPauseButton(false);
                    },
                    onend: () => {
                        this.stopCursorAnimation();
                        this.updatePlayPauseButton(false);
                    },
                    onerror: (error) => {
                        console.error('Audio playback error:', error);
                        this.showError('Failed to load audio file');
                    }
                });
            }

            async playAtTime(timeOffset) {
                if (!this.filename) {
                    console.error('No filename available for audio playback');
                    this.showError('Audio file not available');
                    return;
                }
                
                try {
                    // Stop ALL audio globally first
                    stopAllAudio();
                    
                    // Set this as the current player
                    currentPlayer = this;
                    
                    // Ensure audio is loaded
                    if (!this.audio) {
                        this.preloadAudio();
                    }
                    
                    // Show cursor immediately at click position
                    this.updateCursorPosition(timeOffset);
                    this.cursor.style.display = 'block';
                    
                    // Wait for audio to be loaded if needed
                    if (this.audio && this.audio.state() !== 'loaded') {
                        console.log('Audio not loaded yet, waiting for load event');
                        this.audio.once('load', () => {
                            if (this.audio) {  // Check if still exists
                                console.log('Audio loaded, starting playback');
                                this.audio.seek(timeOffset);
                                this.audio.play();
                                // Don't start animation here - let onplay handle it
                            }
                        });
                    } else if (this.audio) {
                        console.log('Audio already loaded, starting playback immediately');
                        this.audio.seek(timeOffset);
                        this.audio.play();
                        // Don't start animation here - let onplay handle it
                    }
                    
                } catch (error) {
                    console.error('Playback initialization error:', error);
                    this.showError('Audio playback not supported');
                }
            }
            
            startCursorAnimation() {
                console.log('startCursorAnimation called');
                
                // Stop any existing animation
                this.stopCursorAnimation();
                
                // Cursor should already be visible from playAtTime
                this.cursor.style.display = 'block';
                
                const animate = () => {
                    if (this.audio && this.audio.playing()) {
                        const currentTime = this.audio.seek();
                        console.log(`Animation frame: audio playing, currentTime=${currentTime}`);
                        this.updateCursorPosition(currentTime);
                        this.updateTimeDisplay(currentTime);
                        this.animationId = requestAnimationFrame(animate);
                    } else {
                        console.log(`Animation stopped: audio=${!!this.audio}, playing=${this.audio ? this.audio.playing() : 'N/A'}`);
                        // Clear animation ID since we're stopping
                        this.animationId = null;
                    }
                };
                
                // Start the animation loop
                console.log('Starting animation loop');
                this.animationId = requestAnimationFrame(animate);
            }
            
            updateCursorPosition(currentTime) {
                const progress = currentTime / this.duration;
                const containerWidth = this.spectrogramImg.offsetWidth;
                const position = Math.round(progress * containerWidth);
                
                // Debug logging
                console.log(`Cursor update: time=${currentTime.toFixed(2)}s, progress=${(progress*100).toFixed(1)}%, width=${containerWidth}px, position=${position}px`);
                
                this.cursor.style.left = `${position}px`;
            }
            
            stopCursorAnimation() {
                console.log('stopCursorAnimation called, animationId:', this.animationId);
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                // Keep cursor visible but stop animating
            }
            
            togglePlayPause() {
                if (!this.audio) return;
                
                if (this.audio.playing()) {
                    this.audio.pause();
                } else {
                    this.audio.play();
                    this.startCursorAnimation();
                }
            }
            
            stop() {
                if (this.audio) {
                    this.audio.stop();
                    this.stopCursorAnimation();
                }
            }
            
            updatePlayPauseButton(isPlaying) {
                const btn = this.controlsPanel.querySelector('.play-pause-btn');
                if (btn) {
                    btn.textContent = isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
                }
            }
            
            updateTimeDisplay(currentTime) {
                const display = this.controlsPanel.querySelector('.time-display');
                if (display) {
                    const current = this.formatTime(currentTime);
                    const total = this.formatTime(this.duration);
                    display.textContent = `${current} / ${total}`;
                }
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            showError(message) {
                console.error(message);
                const errorMessage = document.getElementById('errorMessage');
                if (errorMessage) {
                    errorMessage.textContent = message;
                    errorMessage.style.display = 'block';
                }
            }
            
            updateFilename(filename) {
                this.filename = filename;
                this.container.dataset.filename = filename;
            }
            
            hideCursor() {
                this.cursor.style.display = 'none';
            }
            
            dispose() {
                if (this.audio) {
                    this.audio.stop();
                    this.audio.unload();
                }
                this.stopCursorAnimation();
                this.hideCursor();
                if (currentPlayer === this) {
                    currentPlayer = null;
                }
            }
        }

        async function loadMelScale() {
            if (melScaleData) {
                return melScaleData;
            }
            
            try {
                const response = await fetch('/api/mel_scale?sample_rate=48000&n_mels=128&fmin=0&fmax=24000');
                if (response.ok) {
                    melScaleData = await response.json();
                    return melScaleData;
                }
            } catch (error) {
                console.error('Error loading mel scale data:', error);
            }
            
            return null;
        }

        function getFrequencyFromPixel(pixelY, canvasHeight) {
            if (!melScaleData || !melScaleData.scale_data) {
                // Fallback to linear scale
                const maxFreq = 24000;
                return Math.round((pixelY / canvasHeight) * maxFreq);
            }
            
            // Find the closest mel scale point
            const scaleIndex = Math.round((pixelY / canvasHeight) * (melScaleData.scale_data.length - 1));
            const clampedIndex = Math.max(0, Math.min(scaleIndex, melScaleData.scale_data.length - 1));
            
            return Math.round(melScaleData.scale_data[clampedIndex].frequency_hz);
        }

        async function loadColormap(colormapName) {
            if (colormapCache[colormapName]) {
                return colormapCache[colormapName];
            }
            
            if (colormapName === 'gray') {
                colormapCache[colormapName] = null;
                return null;
            }
            
            try {
                const response = await fetch(`/api/colormap/${colormapName}`);
                if (response.ok) {
                    const colormap = await response.json();
                    colormapCache[colormapName] = colormap;
                    return colormap;
                }
            } catch (error) {
                console.error(`Error loading colormap ${colormapName}:`, error);
            }
            
            return null;
        }

        async function applyColormap(imageData, colormapName) {
            // Create a copy of the ImageData to avoid modifying the original
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            
            const newImageData = ctx.createImageData(imageData.width, imageData.height);
            const data = newImageData.data;
            const originalData = imageData.data;
            
            try {
                const colormap = await loadColormap(colormapName);
                
                for (let i = 0; i < originalData.length; i += 4) {
                    const gray = originalData[i];
                    
                    if (!colormap || colormapName === 'gray') {
                        data[i] = gray;
                        data[i + 1] = gray;
                        data[i + 2] = gray;
                        data[i + 3] = originalData[i + 3]; // preserve alpha
                    } else {
                        const color = colormap[gray] || [gray, gray, gray];
                        data[i] = color[0];
                        data[i + 1] = color[1];
                        data[i + 2] = color[2];
                        data[i + 3] = originalData[i + 3]; // preserve alpha
                    }
                }
            } catch (error) {
                console.error('Error applying colormap:', error);
                // Fallback to grayscale
                for (let i = 0; i < originalData.length; i += 4) {
                    const gray = originalData[i];
                    data[i] = gray;
                    data[i + 1] = gray;
                    data[i + 2] = gray;
                    data[i + 3] = originalData[i + 3]; // preserve alpha
                }
            }
            
            return newImageData;
        }

        async function loadSpectrogram() {
            const canvas = document.getElementById('spectrogramCanvas');
            const ctx = canvas.getContext('2d');
            const loadingMessage = document.getElementById('loadingMessage');
            const errorMessage = document.getElementById('errorMessage');
            const infoMessage = document.getElementById('infoMessage');
            
            const date = document.getElementById('date').value;
            const timeSlot = document.getElementById('timeSlot').value;
            const colormap = document.getElementById('colormap').value;
            
            loadingMessage.style.display = 'block';
            errorMessage.style.display = 'none';
            infoMessage.style.display = 'none';
            
            try {
                const response = await fetch(`/api/spectrogram?date=${date}&time=${timeSlot}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const blob = await response.blob();
                const img = new Image();
                
                img.onload = async function() {
                    try {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        
                        // Store original grayscale image data
                        window.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Apply saved colormap preference
                        document.getElementById('colormap').value = colormap;
                        const coloredImageData = await applyColormap(window.originalImageData, colormap);
                        
                        console.log('Applying colormap result:', coloredImageData);
                        
                        if (coloredImageData && coloredImageData.data) {
                            ctx.putImageData(coloredImageData, 0, 0);
                            
                            // Apply image adjustments after colormap
                            applyImageAdjustments(canvas);
                        } else {
                            console.error('Invalid ImageData returned from applyColormap');
                            // Fallback: just draw original grayscale
                            ctx.putImageData(window.originalImageData, 0, 0);
                        }
                        
                        const deeplinkUrl = `${window.location.origin}${window.location.pathname}?date=${date}&time=${timeSlot}&colormap=${colormap}`;
                        infoMessage.innerHTML = `Loaded: ${date} ${timeSlot} | ${canvas.width}x${canvas.height} pixels | Colormap: ${colormap} | <a href="${deeplinkUrl}" target="_blank">Deeplink</a>`;
                        infoMessage.style.display = 'block';
                        
                        // Show file path
                        const filePathMessage = document.getElementById('filePathMessage');
                        filePathMessage.innerHTML = `File: ${window.currentFilePath || 'Loading...'}`;
                        filePathMessage.style.display = 'block';
                        
                        URL.revokeObjectURL(img.src);
                    } catch (error) {
                        console.error('Error in img.onload:', error);
                        // Fallback: just show the original image
                        ctx.putImageData(window.originalImageData || ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                    }
                };
                
                img.onerror = function() {
                    errorMessage.textContent = 'Failed to load spectrogram image';
                    errorMessage.style.display = 'block';
                    URL.revokeObjectURL(img.src);
                };
                
                img.src = URL.createObjectURL(blob);
                
            } catch (error) {
                errorMessage.textContent = `Error loading spectrogram: ${error.message}`;
                errorMessage.style.display = 'block';
                console.error('Spectrogram loading error:', error);
            }
        }

        document.getElementById('colormap').addEventListener('change', async function() {
            lastColormap = this.value;
            localStorage.setItem('selectedColormap', lastColormap);
            
            const canvas = document.getElementById('spectrogramCanvas');
            if (canvas.width > 0 && window.originalImageData) {
                const ctx = canvas.getContext('2d');
                const coloredImageData = await applyColormap(window.originalImageData, this.value);
                ctx.putImageData(coloredImageData, 0, 0);
                
                // Apply image adjustments after colormap
                applyImageAdjustments(canvas);
                
                const infoMessage = document.getElementById('infoMessage');
                const date = getCurrentDate();
                const timeSlot = getSelectedTime();
                infoMessage.innerHTML = `Loaded: ${date} ${timeSlot} | ${canvas.width}x${canvas.height} pixels | Colormap: ${this.value}`;
                infoMessage.style.display = 'block';
            }
        });


        let currentSelectedTime = null;
        let availableTimes = {};
        let lastSelectedTime = null;
        let lastColormap = 'viridis';
        let audioPlayer = null;
        let customTimeline = null;

        class CustomTimeline {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.tooltip = document.getElementById('timelineTooltip');
                
                // Timeline state
                this.timeRange = { start: 0, end: 86400000 }; // Default: 24 hours in milliseconds
                this.dataPoints = []; // Array of audio file objects
                this.circles = []; // Processed circle objects
                this.selectedCircle = null;
                
                // View transformation - track time range instead of visual zoom
                this.viewTransform = {
                    panOffset: 0, // time offset in milliseconds
                    zoomLevel: 1, // 1 = full range, >1 = zoomed in (less time visible)
                    minZoom: 0.1, // max time range (10x normal)
                    maxZoom: 50   // min time range (1/50th of normal)
                };
                
                // Store the base time range (set by date picker)
                this.baseTimeRange = { start: 0, end: 86400000 };
                
                // Visual settings
                this.settings = {
                    lineColor: '#666',
                    lineWidth: 1,
                    circleRadius: 6,
                    mergedCircleRadius: 10,
                    singleCircleColor: '#007bff',
                    mergedCircleColor: '#ff6b35',
                    selectedCircleColor: '#dc3545',
                    textColor: 'white',
                    mergeThreshold: 15 // pixels
                };
                
                this.setupCanvas();
                this.bindEvents();
            }
            
            setupCanvas() {
                // Set canvas size properly for crisp rendering
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Set the internal canvas size (in memory)
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Set the display size (CSS pixels)
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Scale the drawing context so everything draws at the correct size
                this.ctx.scale(dpr, dpr);
                
                // Store the logical size for calculations
                this.logicalWidth = rect.width;
                this.logicalHeight = rect.height;
                
                // Initial render if we have data
                if (this.dataPoints.length > 0) {
                    this.render();
                }
            }
            
            bindEvents() {
                let isDragging = false;
                let lastMouseX = 0;
                
                // Mouse events for pan and click
                this.canvas.addEventListener('mousedown', (e) => {
                    // Check if clicking on a point
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const hoveredCircle = this.circles.find(circle => {
                        const dx = mouseX - circle.x;
                        const dy = mouseY - circle.y;
                        return Math.sqrt(dx * dx + dy * dy) <= circle.radius + 5;
                    });
                    
                    if (!hoveredCircle) {
                        // Only start dragging if not clicking on a point
                        isDragging = true;
                        lastMouseX = e.clientX;
                        this.canvas.style.cursor = 'grabbing';
                    }
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - lastMouseX;
                        this.handlePan(deltaX);
                        lastMouseX = e.clientX;
                    } else {
                        this.handleMouseMove(e);
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        // Let the mouse move handler set the correct cursor
                        const mouseEvent = new MouseEvent('mousemove', {
                            clientX: e.clientX,
                            clientY: e.clientY
                        });
                        this.handleMouseMove(mouseEvent);
                    } else {
                        this.handleClick(e);
                    }
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                    this.canvas.classList.remove('over-point');
                    this.hideTooltip();
                });
                
                // Zoom with mouse wheel - very gentle
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    
                    // Very gentle zoom - tiny increments (1% change)
                    const zoomFactor = e.deltaY > 0 ? 0.99 : 1.01;
                    this.handleZoom(zoomFactor, mouseX);
                });
                
                // Handle canvas resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.render();
                });
            }
            
            setTimeRange(startTime, endTime) {
                this.baseTimeRange.start = startTime;
                this.baseTimeRange.end = endTime;
                this.viewTransform.panOffset = 0;
                this.viewTransform.zoomLevel = 1;
                this.updateCurrentTimeRange();
                this.processCircles();
                this.render();
            }
            
            updateCurrentTimeRange() {
                // Calculate current visible time range based on zoom and pan
                const baseSpan = this.baseTimeRange.end - this.baseTimeRange.start;
                const visibleSpan = baseSpan / this.viewTransform.zoomLevel;
                
                const centerTime = this.baseTimeRange.start + (baseSpan / 2) + this.viewTransform.panOffset;
                
                this.timeRange = {
                    start: centerTime - (visibleSpan / 2),
                    end: centerTime + (visibleSpan / 2)
                };
                
                // Clamp to reasonable bounds
                if (this.timeRange.start < this.baseTimeRange.start - baseSpan) {
                    this.timeRange.start = this.baseTimeRange.start - baseSpan;
                    this.timeRange.end = this.timeRange.start + visibleSpan;
                }
                if (this.timeRange.end > this.baseTimeRange.end + baseSpan) {
                    this.timeRange.end = this.baseTimeRange.end + baseSpan;
                    this.timeRange.start = this.timeRange.end - visibleSpan;
                }
            }
            
            setData(audioFiles) {
                this.dataPoints = audioFiles;
                this.allDataPoints = audioFiles; // Keep reference to all data
                this.processCircles();
                this.render();
            }
            
            setAllData(allAudioFiles) {
                // Store all available data points (not filtered by date range)
                this.allDataPoints = allAudioFiles;
                this.dataPoints = allAudioFiles; // Use all data for processing
                this.processCircles();
                this.render();
            }
            
            processCircles() {
                // Convert data points to circles
                const canvasWidth = this.logicalWidth || this.canvas.clientWidth;
                const timeSpan = this.timeRange.end - this.timeRange.start;
                
                // Create initial circles
                const initialCircles = this.dataPoints.map(file => {
                    // Create full timestamp from date and time
                    const fullTimestamp = new Date(file.dateStr + 'T' + file.timeStr + ':00').getTime();
                    const x = ((fullTimestamp - this.timeRange.start) / timeSpan) * canvasWidth;
                    
                    return {
                        x: x,
                        y: (this.logicalHeight || this.canvas.clientHeight) - 50, // Position on the timeline line
                        radius: this.settings.circleRadius,
                        count: 1,
                        files: [file],
                        isMerged: false,
                        timestamp: fullTimestamp
                    };
                }).filter(circle => circle.x >= 0 && circle.x <= canvasWidth);
                
                // Sort by x position
                initialCircles.sort((a, b) => a.x - b.x);
                
                // Merge overlapping circles
                this.circles = [];
                for (const circle of initialCircles) {
                    const lastCircle = this.circles[this.circles.length - 1];
                    
                    if (lastCircle && Math.abs(circle.x - lastCircle.x) <= this.settings.mergeThreshold) {
                        // Merge with previous circle
                        lastCircle.count += circle.count;
                        lastCircle.files.push(...circle.files);
                        lastCircle.isMerged = true;
                        lastCircle.radius = Math.min(this.settings.mergedCircleRadius, 
                            this.settings.circleRadius + lastCircle.count);
                        // Average the x position
                        lastCircle.x = (lastCircle.x + circle.x) / 2;
                    } else {
                        this.circles.push(circle);
                    }
                }
            }
            
            render() {
                const ctx = this.ctx;
                const width = this.logicalWidth || this.canvas.clientWidth;
                const height = this.logicalHeight || this.canvas.clientHeight;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw timeline line (positioned higher to make room for axis)
                const lineY = height - 50;
                ctx.strokeStyle = this.settings.lineColor;
                ctx.lineWidth = this.settings.lineWidth;
                ctx.beginPath();
                ctx.moveTo(0, lineY);
                ctx.lineTo(width, lineY);
                ctx.stroke();
                
                // Draw proper time axis
                this.drawTimeAxis(ctx, width, height, lineY);
                
                // Draw circles (they're already positioned correctly)
                this.circles.forEach(circle => {
                    this.drawCircle(circle);
                });
            }
            
            drawTimeAxis(ctx, width, height, lineY) {
                const timeSpan = this.timeRange.end - this.timeRange.start;
                const dayMs = 24 * 60 * 60 * 1000;
                
                // Determine appropriate tick intervals based on zoom level
                let tickInterval, tickFormat, showMinorTicks;
                
                if (timeSpan > dayMs * 30) {
                    // > 30 days: show months
                    tickInterval = dayMs * 30;
                    tickFormat = 'month';
                    showMinorTicks = false;
                } else if (timeSpan > dayMs * 7) {
                    // > 7 days: show weeks, with day minor ticks
                    tickInterval = dayMs * 7;
                    tickFormat = 'week';
                    showMinorTicks = true;
                } else if (timeSpan > dayMs) {
                    // > 1 day: show days
                    tickInterval = dayMs;
                    tickFormat = 'day';
                    showMinorTicks = true;
                } else if (timeSpan > 6 * 60 * 60 * 1000) {
                    // > 6 hours: show 6-hour intervals
                    tickInterval = 6 * 60 * 60 * 1000;
                    tickFormat = 'hour6';
                    showMinorTicks = true;
                } else {
                    // < 6 hours: show hourly
                    tickInterval = 60 * 60 * 1000;
                    tickFormat = 'hour';
                    showMinorTicks = true;
                }
                
                // Start from the beginning of the first day
                const startDate = new Date(this.timeRange.start);
                startDate.setHours(0, 0, 0, 0);
                let tickTime = startDate.getTime();
                
                // Find the first tick that should be visible
                while (tickTime < this.timeRange.start) {
                    tickTime += tickInterval;
                }
                
                // Draw ticks
                ctx.strokeStyle = '#666';
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                while (tickTime <= this.timeRange.end && tickTime <= this.timeRange.start + timeSpan * 1.1) {
                    const x = ((tickTime - this.timeRange.start) / timeSpan) * width;
                    
                    if (x >= 0 && x <= width) {
                        // Draw major tick line
                        ctx.beginPath();
                        ctx.moveTo(x, lineY);
                        ctx.lineTo(x, lineY + 8);
                        ctx.stroke();
                        
                        // Draw label
                        const label = this.formatAxisLabel(new Date(tickTime), tickFormat);
                        if (label) {
                            ctx.fillText(label, x, lineY + 12);
                        }
                    }
                    
                    tickTime += tickInterval;
                }
                
                // Draw minor ticks (daily) if showing weeks or larger intervals
                if (showMinorTicks && tickFormat !== 'day' && tickFormat !== 'hour' && tickFormat !== 'hour6') {
                    ctx.strokeStyle = '#ccc';
                    const minorInterval = dayMs;
                    let minorTickTime = startDate.getTime();
                    
                    while (minorTickTime < this.timeRange.start) {
                        minorTickTime += minorInterval;
                    }
                    
                    while (minorTickTime <= this.timeRange.end) {
                        const x = ((minorTickTime - this.timeRange.start) / timeSpan) * width;
                        
                        if (x >= 0 && x <= width) {
                            ctx.beginPath();
                            ctx.moveTo(x, lineY);
                            ctx.lineTo(x, lineY + 4);
                            ctx.stroke();
                        }
                        
                        minorTickTime += minorInterval;
                    }
                }
            }
            
            formatAxisLabel(date, format) {
                switch (format) {
                    case 'month':
                        return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                    case 'week':
                        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    case 'day':
                        const daySpan = (this.timeRange.end - this.timeRange.start) / (24 * 60 * 60 * 1000);
                        if (daySpan <= 3) {
                            return date.toLocaleDateString('en-US', { weekday: 'short', day: 'numeric' });
                        }
                        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    case 'hour6':
                        return date.toLocaleTimeString('en-US', { hour: 'numeric', hour12: false }) + ':00';
                    case 'hour':
                        return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: false });
                    default:
                        return '';
                }
            }
            
            drawCircle(circle) {
                const ctx = this.ctx;
                
                // Choose color
                let fillColor = this.settings.singleCircleColor;
                if (circle.isMerged) {
                    fillColor = this.settings.mergedCircleColor;
                } else if (circle === this.selectedCircle) {
                    fillColor = this.settings.selectedCircleColor;
                }
                
                // Draw circle
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw count for merged circles
                if (circle.isMerged && circle.count > 1) {
                    ctx.fillStyle = this.settings.textColor;
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(circle.count.toString(), circle.x, circle.y);
                }
            }
            
            
            handlePan(deltaX) {
                // Convert pixel delta to time delta
                const canvasWidth = this.logicalWidth || this.canvas.clientWidth;
                const timeSpan = this.timeRange.end - this.timeRange.start;
                const timeDelta = (deltaX / canvasWidth) * timeSpan;
                
                // Update pan offset
                this.viewTransform.panOffset -= timeDelta; // negative because we're moving the view
                this.updateCurrentTimeRange();
                this.processCircles();
                this.render();
            }
            
            handleZoom(factor, centerX) {
                const oldZoom = this.viewTransform.zoomLevel;
                const newZoom = Math.max(this.viewTransform.minZoom, 
                    Math.min(this.viewTransform.maxZoom, oldZoom * factor));
                
                if (newZoom !== oldZoom) {
                    // Calculate the time at the center point before zoom
                    const canvasWidth = this.logicalWidth || this.canvas.clientWidth;
                    const timeSpan = this.timeRange.end - this.timeRange.start;
                    const centerTime = this.timeRange.start + (centerX / canvasWidth) * timeSpan;
                    
                    // Update zoom level
                    this.viewTransform.zoomLevel = newZoom;
                    
                    // Adjust pan to keep the center time at the same screen position
                    const baseSpan = this.baseTimeRange.end - this.baseTimeRange.start;
                    const baseCenterTime = this.baseTimeRange.start + (baseSpan / 2);
                    this.viewTransform.panOffset = centerTime - baseCenterTime;
                    
                    this.updateCurrentTimeRange();
                    this.processCircles();
                    this.render();
                }
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find clicked circle
                const clickedCircle = this.circles.find(circle => {
                    const dx = mouseX - circle.x;
                    const dy = mouseY - circle.y;
                    return Math.sqrt(dx * dx + dy * dy) <= circle.radius + 5; // Add some tolerance
                });
                
                if (clickedCircle) {
                    if (clickedCircle.isMerged) {
                        // For merged circles, zoom in to separate them
                        this.zoomToExpandMergedCircle(clickedCircle, mouseX);
                    } else {
                        // For single circles, select normally
                        this.selectedCircle = clickedCircle;
                        this.render();
                        
                        const selectedFile = clickedCircle.files[0];
                        if (selectedFile) {
                            this.selectTimeAndDate(selectedFile.dateStr, selectedFile.timeStr);
                        }
                    }
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find any hovered circle (for cursor and tooltip)
                const hoveredCircle = this.circles.find(circle => {
                    const dx = mouseX - circle.x;
                    const dy = mouseY - circle.y;
                    return Math.sqrt(dx * dx + dy * dy) <= circle.radius + 5;
                });
                
                if (hoveredCircle) {
                    // Change cursor to pointer when over clickable points
                    this.canvas.classList.add('over-point');
                    
                    // Show tooltip only for single circles (not merged)
                    if (!hoveredCircle.isMerged) {
                        this.showTooltip(hoveredCircle, e.clientX, e.clientY);
                    } else {
                        this.hideTooltip();
                    }
                } else {
                    // Reset cursor to grab when not over points
                    this.canvas.classList.remove('over-point');
                    this.hideTooltip();
                }
            }
            
            showTooltip(circle, x, y) {
                if (circle.isMerged) return; // No tooltips for merged circles
                
                const file = circle.files[0];
                this.tooltip.innerHTML = `
                    <div><strong>${file.timeStr}</strong></div>
                    <div>${file.dateStr}</div>
                `;
                
                // Show tooltip, then position it properly
                this.tooltip.style.display = 'block';
                
                // Position above cursor with better offset
                const tooltipHeight = this.tooltip.offsetHeight;
                const tooltipWidth = this.tooltip.offsetWidth;
                
                // Center horizontally on cursor, appear well above it
                this.tooltip.style.left = (x - tooltipWidth / 2) + 'px';
                this.tooltip.style.top = (y - tooltipHeight - 25) + 'px'; // More space above cursor
                
                // Keep tooltip on screen
                const rect = this.tooltip.getBoundingClientRect();
                if (rect.left < 0) {
                    this.tooltip.style.left = '5px';
                }
                if (rect.right > window.innerWidth) {
                    this.tooltip.style.left = (window.innerWidth - tooltipWidth - 5) + 'px';
                }
                if (rect.top < 0) {
                    this.tooltip.style.top = (y + 25) + 'px'; // Show below if no room above
                }
            }
            
            hideTooltip() {
                this.tooltip.style.display = 'none';
            }
            
            selectTimeAndDate(dateStr, timeStr) {
                console.log('Timeline selection:', dateStr, timeStr);
                
                // Update the dropdown selector as backup
                selectTime(timeStr);
                lastSelectedTime = timeStr;
                
                // Update date picker if different date
                const currentDate = getCurrentDate();
                if (dateStr !== currentDate && window.datePicker) {
                    window.datePicker.setDate(dateStr);
                } else {
                    // Same date - load spectrogram directly
                    loadSpectrogram();
                }
            }
            
            resetZoom() {
                this.viewTransform.panOffset = 0;
                this.viewTransform.zoomLevel = 1;
                this.updateCurrentTimeRange();
                this.processCircles();
                this.render();
            }
            
            zoomByFactor(factor) {
                // Calculate center of current view
                const currentCenter = this.timeRange.start + (this.timeRange.end - this.timeRange.start) / 2;
                
                // Apply zoom factor
                const newZoomLevel = Math.max(this.viewTransform.minZoom, 
                    Math.min(this.viewTransform.maxZoom, this.viewTransform.zoomLevel * factor));
                
                if (newZoomLevel !== this.viewTransform.zoomLevel) {
                    this.viewTransform.zoomLevel = newZoomLevel;
                    
                    // Adjust pan to keep the center point centered
                    const baseSpan = this.baseTimeRange.end - this.baseTimeRange.start;
                    const baseCenterTime = this.baseTimeRange.start + (baseSpan / 2);
                    this.viewTransform.panOffset = currentCenter - baseCenterTime;
                    
                    this.updateCurrentTimeRange();
                    this.processCircles();
                    this.render();
                    
                    const currentSpan = (this.timeRange.end - this.timeRange.start) / (60 * 60 * 1000); // in hours
                    console.log(`Zoom ${factor > 1 ? 'in' : 'out'}: ${newZoomLevel.toFixed(2)}x, viewing ${currentSpan.toFixed(1)} hours`);
                }
            }
            
            zoomToExpandMergedCircle(mergedCircle, clickX) {
                // Find the time span of all files in the merged circle
                const timestamps = mergedCircle.files.map(file => 
                    new Date(file.dateStr + 'T' + file.timeStr + ':00').getTime()
                );
                
                const minTime = Math.min(...timestamps);
                const maxTime = Math.max(...timestamps);
                const timeSpan = maxTime - minTime;
                
                // Calculate how much we need to zoom to separate the points
                // We want at least 30 pixels between the farthest points
                const minSeparationPixels = 30;
                const currentPixelsPerMs = (this.logicalWidth || this.canvas.clientWidth) / (this.timeRange.end - this.timeRange.start);
                
                // If they're already separated enough, zoom to show just a small time window around them
                let targetTimeSpan;
                if (timeSpan === 0) {
                    // All files at exact same time - zoom to show 1 hour window
                    targetTimeSpan = 60 * 60 * 1000; // 1 hour
                } else {
                    // Calculate required time span to get minimum separation
                    const requiredTimeSpan = timeSpan * (minSeparationPixels / (timeSpan * currentPixelsPerMs));
                    // Add some padding (2x the required span, minimum 30 minutes)
                    targetTimeSpan = Math.max(requiredTimeSpan * 2, 30 * 60 * 1000);
                }
                
                // Calculate the center time of the merged files
                const centerTime = (minTime + maxTime) / 2;
                
                // Calculate new zoom level
                const baseTimeSpan = this.baseTimeRange.end - this.baseTimeRange.start;
                const newZoomLevel = baseTimeSpan / targetTimeSpan;
                
                // Clamp to our zoom limits
                const clampedZoomLevel = Math.max(this.viewTransform.minZoom, 
                    Math.min(this.viewTransform.maxZoom, newZoomLevel));
                
                // Calculate pan offset to center on the merged circle's time
                const baseCenterTime = this.baseTimeRange.start + (baseTimeSpan / 2);
                const newPanOffset = centerTime - baseCenterTime;
                
                // Apply the new zoom and pan
                this.viewTransform.zoomLevel = clampedZoomLevel;
                this.viewTransform.panOffset = newPanOffset;
                
                // Update and render
                this.updateCurrentTimeRange();
                this.processCircles();
                this.render();
                
                console.log(`Expanded merged circle: ${mergedCircle.files.length} files, zoom: ${clampedZoomLevel.toFixed(2)}x, span: ${(targetTimeSpan/60000).toFixed(1)} min`);
            }
            
            // Update which circle is selected based on time
            updateSelection(timeStr) {
                this.selectedCircle = null;
                
                // Find circle that matches the time
                for (const circle of this.circles) {
                    for (const file of circle.files) {
                        if (file.timeStr === timeStr) {
                            this.selectedCircle = circle;
                            this.render();
                            return;
                        }
                    }
                }
                
                // No match found, clear selection
                this.render();
            }
        }
        
        // Helper function to get selected time
        function getSelectedTime() {
            const selector = document.getElementById('timeSlotSelector');
            return selector ? selector.value : '';
        }

        // Helper function to safely get current date
        function getCurrentDate() {
            if (window.datePicker) {
                try {
                    // Handle range picker - get start date
                    const startDate = window.datePicker.getStartDate();
                    if (startDate) {
                        return startDate.format('YYYY-MM-DD');
                    }
                    
                    // Fallback to single date
                    const singleDate = window.datePicker.getDate();
                    if (singleDate) {
                        return singleDate.format('YYYY-MM-DD');
                    }
                } catch (e) {
                    console.warn('Error getting date from easepick:', e);
                }
            }
            // Fallback to input value
            return document.getElementById('datepicker').value || '2025-06-20';
        }

        function changeDate(direction) {
            // Stop any currently playing audio when changing dates
            stopAllAudio();
            
            if (!window.datePicker) return;
            
            const currentDate = window.datePicker.getDate();
            if (currentDate) {
                const newDate = new Date(currentDate);
                newDate.setDate(newDate.getDate() + direction);
                window.datePicker.setDate(newDate);
                // The select event will trigger loadAvailableTimes()
            }
        }

        async function navigateToFile(direction) {
            // Stop any currently playing audio
            stopAllAudio();
            
            const currentDate = getCurrentDate();
            
            const currentTime = getSelectedTime();
            if (!currentTime) {
                console.log('No time slot selected, cannot navigate');
                return;
            }
            
            try {
                const response = await fetch(`/api/navigation?date=${currentDate}&time=${currentTime}&direction=${direction}`);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        const errorMessage = document.getElementById('errorMessage');
                        errorMessage.textContent = `No ${direction} file available`;
                        errorMessage.style.display = 'block';
                        setTimeout(() => {
                            errorMessage.style.display = 'none';
                        }, 2000);
                    }
                    return;
                }
                
                const navData = await response.json();
                
                // Update date if needed
                if (navData.date !== currentDate) {
                    if (window.datePicker) {
                        window.datePicker.setDate(navData.date);
                    }
                    await loadAvailableTimes();
                }
                
                // Select the new time slot
                if (availableTimes[navData.date] && availableTimes[navData.date].includes(navData.time)) {
                    // Select new time in selector
                    selectTime(navData.time);
                    lastSelectedTime = navData.time;
                    
                    // Load the new spectrogram
                    await loadSpectrogram();
                } else {
                    console.error('New time slot not found or not available:', navData.time);
                }
                
            } catch (error) {
                console.error('Error navigating to file:', error);
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = `Error navigating to ${direction} file`;
                errorMessage.style.display = 'block';
                setTimeout(() => {
                    errorMessage.style.display = 'none';
                }, 2000);
            }
        }

        function selectTime(timeStr) {
            const selector = document.getElementById('timeSlotSelector');
            if (selector) {
                selector.value = timeStr;
                lastSelectedTime = timeStr;
            }
            
            // Update timeline selection
            if (customTimeline) {
                customTimeline.updateSelection(timeStr);
            }
        }

        function resetTimelineZoom() {
            if (customTimeline) {
                customTimeline.resetZoom();
            }
        }

        function zoomTimelineIn() {
            if (customTimeline) {
                customTimeline.zoomByFactor(2.0); // Halve the time range (zoom in)
            }
        }

        function zoomTimelineOut() {
            if (customTimeline) {
                customTimeline.zoomByFactor(0.5); // Double the time range (zoom out)
            }
        }

        function initializeCustomTimeline() {
            customTimeline = new CustomTimeline('customTimeline');
            console.log('Custom timeline initialized');
        }

        async function loadAvailableTimes() {
            try {
                console.log('Loading available times...');
                const response = await fetch('/api/available_times');
                const data = await response.json();
                console.log('Available times loaded:', data);
                availableTimes = data;
                updateTimeGrid();
            } catch (error) {
                console.error('Error loading available times:', error);
            }
        }

        function updateTimeGrid() {
            const currentDate = getCurrentDate();
            console.log('updateTimeGrid() called', { currentDate, availableTimes });
            
            // Update dropdown selector
            const selector = document.getElementById('timeSlotSelector');
            if (selector) {
                // Clear existing options
                selector.innerHTML = '<option value="">Select a time slot...</option>';
                
                // Populate with available times for current date
                if (currentDate && availableTimes[currentDate]) {
                    availableTimes[currentDate].forEach(timeStr => {
                        const option = document.createElement('option');
                        option.value = timeStr;
                        option.textContent = timeStr;
                        selector.appendChild(option);
                    });
                }
            }
            
            // Update custom timeline with all data if not already set
            if (customTimeline && currentDate && availableTimes[currentDate]) {
                // Only update if we don't have all data loaded yet
                if (!customTimeline.allDataPoints || customTimeline.allDataPoints.length === 0) {
                    // Collect ALL available data points
                    const allDataPoints = [];
                    Object.keys(availableTimes).forEach(dateStr => {
                        availableTimes[dateStr].forEach(timeStr => {
                            allDataPoints.push({
                                dateStr: dateStr,
                                timeStr: timeStr
                            });
                        });
                    });
                    
                    customTimeline.setAllData(allDataPoints);
                    
                    // Set initial view to current date
                    const startOfDay = new Date(currentDate + 'T00:00:00').getTime();
                    const endOfDay = new Date(currentDate + 'T23:59:59').getTime();
                    customTimeline.setTimeRange(startOfDay, endOfDay);
                    
                    console.log(`Timeline updated with ${allDataPoints.length} total data points, viewing ${currentDate}`);
                }
            }
            
            // Re-select the same time if it was previously selected and is available
            if (lastSelectedTime && currentDate && availableTimes[currentDate] && 
                availableTimes[currentDate].includes(lastSelectedTime)) {
                console.log('Re-selecting time:', lastSelectedTime);
                selectTime(lastSelectedTime);
                // Auto-load the spectrogram
                setTimeout(async () => await loadSpectrogram(), 100);
            } else {
                // Clear selection if the time is not available on the new date
                if (lastSelectedTime) {
                    console.log('Clearing selection - time not available');
                    lastSelectedTime = null;
                }
            }
        }

        async function loadSpectrogram() {
            const canvas = document.getElementById('spectrogramCanvas');
            const ctx = canvas.getContext('2d');
            const errorMessage = document.getElementById('errorMessage');
            const infoMessage = document.getElementById('infoMessage');
            
            const date = getCurrentDate();
            
            const timeSlot = getSelectedTime();
            if (!timeSlot) {
                errorMessage.textContent = 'Please select a time slot';
                errorMessage.style.display = 'block';
                return;
            }
            
            // Always use the saved colormap preference
            const colormap = lastColormap || document.getElementById('colormap').value;
            console.log('Loading with colormap:', colormap, 'lastColormap:', lastColormap);
            
            // Load mel scale data for frequency calculations
            await loadMelScale();
            
            errorMessage.style.display = 'none';
            infoMessage.style.display = 'none';
            
            try {
                const response = await fetch(`/api/spectrogram?date=${date}&time=${timeSlot}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Get file path info and initialize audio player
                try {
                    const fileInfoResponse = await fetch(`/api/file_info?date=${date}&time=${timeSlot}`);
                    if (fileInfoResponse.ok) {
                        const fileInfo = await fileInfoResponse.json();
                        window.currentFilePath = fileInfo.filepath;
                        
                        // Initialize audio player with filename
                        const spectrogramContainer = document.querySelector('.spectrogram-container');
                        if (spectrogramContainer && fileInfo.filename) {
                            // Dispose of existing player
                            if (audioPlayer) {
                                audioPlayer.dispose();
                            }
                            
                            // Update container with filename and create new player
                            spectrogramContainer.dataset.filename = fileInfo.filename;
                            audioPlayer = new SpectrogramAudioPlayer(spectrogramContainer);
                            
                            // Show controls
                            const controlsPanel = document.querySelector('.control-group.playback-controls');
                            if (controlsPanel) {
                                controlsPanel.classList.add('has-audio');
                            }
                        }
                    }
                } catch (e) {
                    console.log('Could not fetch file info:', e);
                }
                
                // Fetch weather data
                try {
                    const weatherResponse = await fetch(`/api/weather?date=${date}&time=${timeSlot}`);
                    if (weatherResponse.ok) {
                        const weatherData = await weatherResponse.json();
                        updateWeatherDisplay(weatherData);
                    } else {
                        clearWeatherDisplay();
                    }
                } catch (e) {
                    console.log('Could not fetch weather data:', e);
                    clearWeatherDisplay();
                }
                
                const blob = await response.blob();
                const img = new Image();
                
                img.onload = async function() {
                    try {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        ctx.drawImage(img, 0, 0);
                        
                        // Store original grayscale image data
                        window.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        // Apply saved colormap preference
                        document.getElementById('colormap').value = colormap;
                        const coloredImageData = await applyColormap(window.originalImageData, colormap);
                        
                        console.log('Applying colormap result:', coloredImageData);
                        
                        if (coloredImageData && coloredImageData.data) {
                            ctx.putImageData(coloredImageData, 0, 0);
                            
                            // Apply image adjustments after colormap
                            applyImageAdjustments(canvas);
                        } else {
                            console.error('Invalid ImageData returned from applyColormap');
                            // Fallback: just draw original grayscale
                            ctx.putImageData(window.originalImageData, 0, 0);
                        }
                        
                        const deeplinkUrl = `${window.location.origin}${window.location.pathname}?date=${date}&time=${timeSlot}&colormap=${colormap}`;
                        infoMessage.innerHTML = `Loaded: ${date} ${timeSlot} | ${canvas.width}x${canvas.height} pixels | Colormap: ${colormap} | <a href="${deeplinkUrl}" target="_blank">Deeplink</a>`;
                        infoMessage.style.display = 'block';
                        
                        // Show file path
                        const filePathMessage = document.getElementById('filePathMessage');
                        filePathMessage.innerHTML = `File: ${window.currentFilePath || 'Loading...'}`;
                        filePathMessage.style.display = 'block';
                        
                        URL.revokeObjectURL(img.src);
                    } catch (error) {
                        console.error('Error in img.onload:', error);
                        // Fallback: just show the original image
                        ctx.putImageData(window.originalImageData || ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                    }
                };
                
                img.onerror = function() {
                    errorMessage.textContent = 'Failed to load spectrogram image';
                    errorMessage.style.display = 'block';
                    URL.revokeObjectURL(img.src);
                };
                
                img.src = URL.createObjectURL(blob);
                
            } catch (error) {
                loadingMessage.style.display = 'none';
                errorMessage.textContent = `Error loading spectrogram: ${error.message}`;
                errorMessage.style.display = 'block';
            }
        }

        // Mouse tracking for coordinates and crosshairs
        document.getElementById('spectrogramCanvas').addEventListener('mousemove', function(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = Math.round(event.clientX - rect.left);
            const y = Math.round(event.clientY - rect.top);
            
            // Convert y to bottom-left origin (0,0 at bottom left)
            const yBottomLeft = canvas.height - y;
            
            // Update crosshairs
            const verticalLine = document.getElementById('crosshairVertical');
            const horizontalLine = document.getElementById('crosshairHorizontal');
            
            verticalLine.style.left = x + 'px';
            verticalLine.style.display = 'block';
            
            horizontalLine.style.top = y + 'px';
            horizontalLine.style.display = 'block';
            
            // Calculate frequency using mel scale
            const frequency = getFrequencyFromPixel(yBottomLeft, canvas.height);
            
            // Calculate time within the 15-minute recording
            const recordingDuration = 15 * 60; // 15 minutes in seconds
            const timeInRecording = (x / canvas.width) * recordingDuration;
            
            // Get base time from current selection and add offset
            const selectedTime = getSelectedTime();
            if (selectedTime) {
                const [baseHour, baseMinute] = selectedTime.split(':').map(Number);
                
                const totalSeconds = baseHour * 3600 + baseMinute * 60 + timeInRecording;
                const hours = Math.floor(totalSeconds / 3600) % 24;
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = Math.floor(totalSeconds % 60);
                
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update coordinate displays
                document.getElementById('pixelCoords').textContent = `x:${x.toString().padStart(4, '0')} y:${yBottomLeft.toString().padStart(4, '0')}`;
                document.getElementById('timeCoords').textContent = `Time: ${timeString}`;
                document.getElementById('freqCoords').textContent = `Freq: ${frequency.toString().padStart(4, '0')} Hz`;
            }
        });

        document.getElementById('spectrogramCanvas').addEventListener('mouseleave', function() {
            // Hide crosshairs
            document.getElementById('crosshairVertical').style.display = 'none';
            document.getElementById('crosshairHorizontal').style.display = 'none';
            
            // Reset to default values
            document.getElementById('pixelCoords').textContent = 'x:---- y:----';
            document.getElementById('timeCoords').textContent = 'Time: --:--:--';
            document.getElementById('freqCoords').textContent = 'Freq: ---- Hz';
        });

        // Date picker change event will be handled by easepick

        window.addEventListener('load', function() {
            console.log('Page loaded, initializing...');
            
            // Check easepick availability
            if (typeof easepick === 'undefined') {
                console.error('easepick not loaded!');
                return;
            }
            
            console.log('easepick loaded:', typeof easepick);
            
            // Check for URL parameters for deeplink functionality
            const urlParams = new URLSearchParams(window.location.search);
            const paramDate = urlParams.get('date');
            const paramTime = urlParams.get('time');
            const paramColormap = urlParams.get('colormap');
            
            // Set date from URL parameter or default
            const dateValue = paramDate || '2025-06-20';
            console.log('Set date to:', dateValue);
            
            // Wait for available times to load, then initialize easepick
            loadAvailableTimes().then(() => {
                // Get available dates from the loaded data
                const availableDates = Object.keys(availableTimes).sort();
                console.log('Available dates for easepick:', availableDates);
                
                try {
                    const picker = new easepick.create({
                        element: document.getElementById('datepicker'),
                        css: [
                            'https://cdn.jsdelivr.net/npm/@easepick/bundle@1.2.1/dist/index.css',
                        ],
                        plugins: ['RangePlugin', 'LockPlugin'],
                        format: "YYYY-MM-DD",
                        date: dateValue,
                        RangePlugin: {
                            tooltipNumber(num) {
                                return num - 1;
                            },
                            locale: {
                                one: 'day',
                                other: 'days'
                            }
                        },
                        LockPlugin: {
                            filter(date, picked) {
                                // Lock dates that are NOT in our available dates
                                return !availableDates.includes(date.format('YYYY-MM-DD'));
                            },
                        },
                        setup(picker) {
                            picker.on('select', (e) => {
                                // Handle both single dates and ranges
                                let selectedDate, endDate;
                                
                                if (e.detail.date) {
                                    // Single date selection
                                    selectedDate = e.detail.date.format('YYYY-MM-DD');
                                    endDate = selectedDate;
                                } else if (e.detail.start && e.detail.end) {
                                    // Range selection
                                    selectedDate = e.detail.start.format('YYYY-MM-DD');
                                    endDate = e.detail.end.format('YYYY-MM-DD');
                                }
                                
                                console.log('Easepick selection:', selectedDate, 'to', endDate);
                                
                                // Collect ALL available data points (not just selected range)
                                if (customTimeline) {
                                    const allDataPoints = [];
                                    Object.keys(availableTimes).forEach(dateStr => {
                                        availableTimes[dateStr].forEach(timeStr => {
                                            allDataPoints.push({
                                                dateStr: dateStr,
                                                timeStr: timeStr
                                            });
                                        });
                                    });
                                    
                                    // Set all data first
                                    customTimeline.setAllData(allDataPoints);
                                    
                                    // Then set the initial view range based on selection
                                    if (selectedDate === endDate) {
                                        // Single date - show that day (00:00 to 23:59)
                                        const startOfDay = new Date(selectedDate + 'T00:00:00').getTime();
                                        const endOfDay = new Date(selectedDate + 'T23:59:59').getTime();
                                        customTimeline.setTimeRange(startOfDay, endOfDay);
                                    } else {
                                        // Date range - show range from 00:00 of start to 23:59 of end
                                        const startOfRange = new Date(selectedDate + 'T00:00:00').getTime();
                                        const endOfRange = new Date(endDate + 'T23:59:59').getTime();
                                        customTimeline.setTimeRange(startOfRange, endOfRange);
                                    }
                                    
                                    console.log(`Timeline loaded with ${allDataPoints.length} total data points, viewing ${selectedDate} to ${endDate}`);
                                }
                                
                                // Update dropdown selector for current date
                                updateTimeGrid();
                                
                                // Clear any previous time selection when date changes
                                lastSelectedTime = null;
                            });
                        }
                    });
                    
                    window.datePicker = picker;
                    console.log('easepick initialized successfully with', availableDates.length, 'available dates');
                    
                } catch (error) {
                    console.error('Failed to initialize easepick:', error);
                    // Fallback: set the input value directly
                    document.getElementById('datepicker').value = dateValue;
                }
            });
            
            // Restore saved colormap or use URL parameter
            const savedColormap = paramColormap || localStorage.getItem('selectedColormap');
            if (savedColormap) {
                lastColormap = savedColormap;
                document.getElementById('colormap').value = savedColormap;
            }
            
            // Initialize custom timeline
            initializeCustomTimeline();
            
            // Initialize time selector change handler
            const timeSelector = document.getElementById('timeSlotSelector');
            if (timeSelector) {
                timeSelector.addEventListener('change', function() {
                    lastSelectedTime = this.value;
                    if (this.value) {
                        console.log('Time slot selected:', this.value);
                        loadSpectrogram();
                    }
                });
            }
            
            // Then load available times
            console.log('Loading available times...');
            loadAvailableTimes().then(() => {
                // If we have URL parameters, select the specified time
                if (paramTime && availableTimes[dateValue] && availableTimes[dateValue].includes(paramTime)) {
                    console.log('Selecting paramTime:', paramTime);
                    selectTime(paramTime);
                }
            });
            
            // Setup gamma control
            const gammaSlider = document.getElementById('gamma');
            gammaSlider.addEventListener('input', function() {
                imageAdjustments.gamma = parseFloat(this.value);
                updateAdjustmentDisplays();
                
                const canvas = document.getElementById('spectrogramCanvas');
                if (canvas && window.originalImageData) {
                    // Reapply colormap first, then gamma
                    const colormap = document.getElementById('colormap').value;
                    applyColormap(window.originalImageData, colormap).then(coloredImageData => {
                        const ctx = canvas.getContext('2d');
                        ctx.putImageData(coloredImageData, 0, 0);
                        applyImageAdjustments(canvas);
                    });
                }
            });
            
            // Double-click to reset gamma
            gammaSlider.addEventListener('dblclick', resetGamma);
            
            // Initialize gamma display
            updateAdjustmentDisplays();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (audioPlayer) {
                audioPlayer.dispose();
            }
        });
    </script>
</body>
</html>